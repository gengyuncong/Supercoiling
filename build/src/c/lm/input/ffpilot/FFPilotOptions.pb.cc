// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: lm/input/ffpilot/FFPilotOptions.proto

#include "lm/input/ffpilot/FFPilotOptions.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_robertslab_2fpbuf_2fNDArray_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_NDArray_robertslab_2fpbuf_2fNDArray_2eproto;
namespace lm {
namespace input {
namespace ffpilot {
class FFPilotOptionsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FFPilotOptions> _instance;
} _FFPilotOptions_default_instance_;
}  // namespace ffpilot
}  // namespace input
}  // namespace lm
static void InitDefaultsscc_info_FFPilotOptions_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::lm::input::ffpilot::_FFPilotOptions_default_instance_;
    new (ptr) ::lm::input::ffpilot::FFPilotOptions();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::lm::input::ffpilot::FFPilotOptions::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_FFPilotOptions_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_FFPilotOptions_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto}, {
      &scc_info_NDArray_robertslab_2fpbuf_2fNDArray_2eproto.base,}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto[1];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto[1];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::lm::input::ffpilot::FFPilotOptions, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::lm::input::ffpilot::FFPilotOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::lm::input::ffpilot::FFPilotOptions, error_goal_),
  PROTOBUF_FIELD_OFFSET(::lm::input::ffpilot::FFPilotOptions, error_goal_confidence_),
  PROTOBUF_FIELD_OFFSET(::lm::input::ffpilot::FFPilotOptions, order_parameter_index_),
  PROTOBUF_FIELD_OFFSET(::lm::input::ffpilot::FFPilotOptions, tiling_index_),
  PROTOBUF_FIELD_OFFSET(::lm::input::ffpilot::FFPilotOptions, trajectory_output_),
  PROTOBUF_FIELD_OFFSET(::lm::input::ffpilot::FFPilotOptions, max_trajectories_per_work_unit_),
  PROTOBUF_FIELD_OFFSET(::lm::input::ffpilot::FFPilotOptions, fallback_method_),
  PROTOBUF_FIELD_OFFSET(::lm::input::ffpilot::FFPilotOptions, phase_zero_basins_),
  PROTOBUF_FIELD_OFFSET(::lm::input::ffpilot::FFPilotOptions, phase_zero_transition_barrier_),
  PROTOBUF_FIELD_OFFSET(::lm::input::ffpilot::FFPilotOptions, phase_zero_equilibration_crossings_),
  PROTOBUF_FIELD_OFFSET(::lm::input::ffpilot::FFPilotOptions, pilot_stage_crossings_),
  PROTOBUF_FIELD_OFFSET(::lm::input::ffpilot::FFPilotOptions, pilot_skip_),
  PROTOBUF_FIELD_OFFSET(::lm::input::ffpilot::FFPilotOptions, prod_trajectory_counts_),
  PROTOBUF_FIELD_OFFSET(::lm::input::ffpilot::FFPilotOptions, prod_skip_),
  PROTOBUF_FIELD_OFFSET(::lm::input::ffpilot::FFPilotOptions, optimize_minimum_trajectories_),
  PROTOBUF_FIELD_OFFSET(::lm::input::ffpilot::FFPilotOptions, optimize_sampling_multipliers_),
  PROTOBUF_FIELD_OFFSET(::lm::input::ffpilot::FFPilotOptions, optimize_minimize_cost_),
  11,
  12,
  3,
  4,
  7,
  13,
  6,
  0,
  5,
  14,
  15,
  8,
  1,
  9,
  16,
  2,
  10,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 22, sizeof(::lm::input::ffpilot::FFPilotOptions)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::lm::input::ffpilot::_FFPilotOptions_default_instance_),
};

const char descriptor_table_protodef_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n%lm/input/ffpilot/FFPilotOptions.proto\022"
  "\020lm.input.ffpilot\032\035robertslab/pbuf/NDArr"
  "ay.proto\"\266\006\n\016FFPilotOptions\022\030\n\nerror_goa"
  "l\030\001 \001(\001:\0040.05\022#\n\025error_goal_confidence\030\002"
  " \001(\001:\0040.95\022 \n\025order_parameter_index\030\003 \001("
  "\005:\0010\022\027\n\014tiling_index\030\004 \001(\005:\0010\022 \n\021traject"
  "ory_output\030\005 \001(\010:\005false\022-\n\036max_trajector"
  "ies_per_work_unit\030\006 \001(\004:\00510000\022^\n\017fallba"
  "ck_method\030\007 \001(\0162/.lm.input.ffpilot.FFPil"
  "otOptions.FallbackMethod:\024FALLBACK_TILIN"
  "G_EDGE\0223\n\021phase_zero_basins\030d \002(\0132\030.robe"
  "rtslab.pbuf.NDArray\022%\n\035phase_zero_transi"
  "tion_barrier\030e \001(\001\022.\n\"phase_zero_equilib"
  "ration_crossings\030f \001(\005:\00210\022$\n\025pilot_stag"
  "e_crossings\030\254\002 \001(\005:\0041000\022\032\n\npilot_skip\030\255"
  "\002 \001(\010:\005false\0229\n\026prod_trajectory_counts\030\221"
  "\003 \001(\0132\030.robertslab.pbuf.NDArray\022\031\n\tprod_"
  "skip\030\256\002 \001(\010:\005false\022,\n\035optimize_minimum_t"
  "rajectories\030\204\007 \001(\004:\0041000\022@\n\035optimize_sam"
  "pling_multipliers\030\205\007 \001(\0132\030.robertslab.pb"
  "uf.NDArray\022%\n\026optimize_minimize_cost\030\206\007 "
  "\001(\010:\004true\">\n\016FallbackMethod\022\030\n\024FALLBACK_"
  "TILING_EDGE\020\000\022\022\n\016FALLBACK_BASIN\020\001"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto_deps[1] = {
  &::descriptor_table_robertslab_2fpbuf_2fNDArray_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto_sccs[1] = {
  &scc_info_FFPilotOptions_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto = {
  false, false, descriptor_table_protodef_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto, "lm/input/ffpilot/FFPilotOptions.proto", 913,
  &descriptor_table_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto_once, descriptor_table_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto_sccs, descriptor_table_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto_deps, 1, 1,
  schemas, file_default_instances, TableStruct_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto::offsets,
  file_level_metadata_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto, 1, file_level_enum_descriptors_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto, file_level_service_descriptors_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto = (static_cast<void>(::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto)), true);
namespace lm {
namespace input {
namespace ffpilot {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FFPilotOptions_FallbackMethod_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto);
  return file_level_enum_descriptors_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto[0];
}
bool FFPilotOptions_FallbackMethod_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr FFPilotOptions_FallbackMethod FFPilotOptions::FALLBACK_TILING_EDGE;
constexpr FFPilotOptions_FallbackMethod FFPilotOptions::FALLBACK_BASIN;
constexpr FFPilotOptions_FallbackMethod FFPilotOptions::FallbackMethod_MIN;
constexpr FFPilotOptions_FallbackMethod FFPilotOptions::FallbackMethod_MAX;
constexpr int FFPilotOptions::FallbackMethod_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void FFPilotOptions::InitAsDefaultInstance() {
  ::lm::input::ffpilot::_FFPilotOptions_default_instance_._instance.get_mutable()->phase_zero_basins_ = const_cast< ::robertslab::pbuf::NDArray*>(
      ::robertslab::pbuf::NDArray::internal_default_instance());
  ::lm::input::ffpilot::_FFPilotOptions_default_instance_._instance.get_mutable()->prod_trajectory_counts_ = const_cast< ::robertslab::pbuf::NDArray*>(
      ::robertslab::pbuf::NDArray::internal_default_instance());
  ::lm::input::ffpilot::_FFPilotOptions_default_instance_._instance.get_mutable()->optimize_sampling_multipliers_ = const_cast< ::robertslab::pbuf::NDArray*>(
      ::robertslab::pbuf::NDArray::internal_default_instance());
}
class FFPilotOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<FFPilotOptions>()._has_bits_);
  static void set_has_error_goal(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_error_goal_confidence(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_order_parameter_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_tiling_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_trajectory_output(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_max_trajectories_per_work_unit(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_fallback_method(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::robertslab::pbuf::NDArray& phase_zero_basins(const FFPilotOptions* msg);
  static void set_has_phase_zero_basins(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_phase_zero_transition_barrier(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_phase_zero_equilibration_crossings(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_pilot_stage_crossings(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_pilot_skip(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::robertslab::pbuf::NDArray& prod_trajectory_counts(const FFPilotOptions* msg);
  static void set_has_prod_trajectory_counts(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prod_skip(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_optimize_minimum_trajectories(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::robertslab::pbuf::NDArray& optimize_sampling_multipliers(const FFPilotOptions* msg);
  static void set_has_optimize_sampling_multipliers(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_optimize_minimize_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::robertslab::pbuf::NDArray&
FFPilotOptions::_Internal::phase_zero_basins(const FFPilotOptions* msg) {
  return *msg->phase_zero_basins_;
}
const ::robertslab::pbuf::NDArray&
FFPilotOptions::_Internal::prod_trajectory_counts(const FFPilotOptions* msg) {
  return *msg->prod_trajectory_counts_;
}
const ::robertslab::pbuf::NDArray&
FFPilotOptions::_Internal::optimize_sampling_multipliers(const FFPilotOptions* msg) {
  return *msg->optimize_sampling_multipliers_;
}
void FFPilotOptions::clear_phase_zero_basins() {
  if (phase_zero_basins_ != nullptr) phase_zero_basins_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void FFPilotOptions::clear_prod_trajectory_counts() {
  if (prod_trajectory_counts_ != nullptr) prod_trajectory_counts_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void FFPilotOptions::clear_optimize_sampling_multipliers() {
  if (optimize_sampling_multipliers_ != nullptr) optimize_sampling_multipliers_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
FFPilotOptions::FFPilotOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:lm.input.ffpilot.FFPilotOptions)
}
FFPilotOptions::FFPilotOptions(const FFPilotOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_phase_zero_basins()) {
    phase_zero_basins_ = new ::robertslab::pbuf::NDArray(*from.phase_zero_basins_);
  } else {
    phase_zero_basins_ = nullptr;
  }
  if (from._internal_has_prod_trajectory_counts()) {
    prod_trajectory_counts_ = new ::robertslab::pbuf::NDArray(*from.prod_trajectory_counts_);
  } else {
    prod_trajectory_counts_ = nullptr;
  }
  if (from._internal_has_optimize_sampling_multipliers()) {
    optimize_sampling_multipliers_ = new ::robertslab::pbuf::NDArray(*from.optimize_sampling_multipliers_);
  } else {
    optimize_sampling_multipliers_ = nullptr;
  }
  ::memcpy(&order_parameter_index_, &from.order_parameter_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&optimize_minimum_trajectories_) -
    reinterpret_cast<char*>(&order_parameter_index_)) + sizeof(optimize_minimum_trajectories_));
  // @@protoc_insertion_point(copy_constructor:lm.input.ffpilot.FFPilotOptions)
}

void FFPilotOptions::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FFPilotOptions_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto.base);
  ::memset(&phase_zero_basins_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&prod_skip_) -
      reinterpret_cast<char*>(&phase_zero_basins_)) + sizeof(prod_skip_));
  optimize_minimize_cost_ = true;
  error_goal_ = 0.05;
  error_goal_confidence_ = 0.95;
  max_trajectories_per_work_unit_ = PROTOBUF_ULONGLONG(10000);
  phase_zero_equilibration_crossings_ = 10;
  pilot_stage_crossings_ = 1000;
  optimize_minimum_trajectories_ = PROTOBUF_ULONGLONG(1000);
}

FFPilotOptions::~FFPilotOptions() {
  // @@protoc_insertion_point(destructor:lm.input.ffpilot.FFPilotOptions)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void FFPilotOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete phase_zero_basins_;
  if (this != internal_default_instance()) delete prod_trajectory_counts_;
  if (this != internal_default_instance()) delete optimize_sampling_multipliers_;
}

void FFPilotOptions::ArenaDtor(void* object) {
  FFPilotOptions* _this = reinterpret_cast< FFPilotOptions* >(object);
  (void)_this;
}
void FFPilotOptions::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FFPilotOptions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FFPilotOptions& FFPilotOptions::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FFPilotOptions_lm_2finput_2fffpilot_2fFFPilotOptions_2eproto.base);
  return *internal_default_instance();
}


void FFPilotOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:lm.input.ffpilot.FFPilotOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(phase_zero_basins_ != nullptr);
      phase_zero_basins_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(prod_trajectory_counts_ != nullptr);
      prod_trajectory_counts_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(optimize_sampling_multipliers_ != nullptr);
      optimize_sampling_multipliers_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&order_parameter_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&trajectory_output_) -
        reinterpret_cast<char*>(&order_parameter_index_)) + sizeof(trajectory_output_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&pilot_skip_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&prod_skip_) -
        reinterpret_cast<char*>(&pilot_skip_)) + sizeof(prod_skip_));
    optimize_minimize_cost_ = true;
    error_goal_ = 0.05;
    error_goal_confidence_ = 0.95;
    max_trajectories_per_work_unit_ = PROTOBUF_ULONGLONG(10000);
    phase_zero_equilibration_crossings_ = 10;
    pilot_stage_crossings_ = 1000;
  }
  optimize_minimum_trajectories_ = PROTOBUF_ULONGLONG(1000);
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FFPilotOptions::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional double error_goal = 1 [default = 0.05];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_error_goal(&has_bits);
          error_goal_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double error_goal_confidence = 2 [default = 0.95];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_error_goal_confidence(&has_bits);
          error_goal_confidence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional int32 order_parameter_index = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_order_parameter_index(&has_bits);
          order_parameter_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 tiling_index = 4 [default = 0];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_tiling_index(&has_bits);
          tiling_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool trajectory_output = 5 [default = false];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_trajectory_output(&has_bits);
          trajectory_output_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 max_trajectories_per_work_unit = 6 [default = 10000];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_max_trajectories_per_work_unit(&has_bits);
          max_trajectories_per_work_unit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .lm.input.ffpilot.FFPilotOptions.FallbackMethod fallback_method = 7 [default = FALLBACK_TILING_EDGE];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::lm::input::ffpilot::FFPilotOptions_FallbackMethod_IsValid(val))) {
            _internal_set_fallback_method(static_cast<::lm::input::ffpilot::FFPilotOptions_FallbackMethod>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // required .robertslab.pbuf.NDArray phase_zero_basins = 100;
      case 100:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_phase_zero_basins(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional double phase_zero_transition_barrier = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _Internal::set_has_phase_zero_transition_barrier(&has_bits);
          phase_zero_transition_barrier_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional int32 phase_zero_equilibration_crossings = 102 [default = 10];
      case 102:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_phase_zero_equilibration_crossings(&has_bits);
          phase_zero_equilibration_crossings_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 pilot_stage_crossings = 300 [default = 1000];
      case 300:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_pilot_stage_crossings(&has_bits);
          pilot_stage_crossings_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool pilot_skip = 301 [default = false];
      case 301:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_pilot_skip(&has_bits);
          pilot_skip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool prod_skip = 302 [default = false];
      case 302:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_prod_skip(&has_bits);
          prod_skip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .robertslab.pbuf.NDArray prod_trajectory_counts = 401;
      case 401:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_prod_trajectory_counts(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 optimize_minimum_trajectories = 900 [default = 1000];
      case 900:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_optimize_minimum_trajectories(&has_bits);
          optimize_minimum_trajectories_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .robertslab.pbuf.NDArray optimize_sampling_multipliers = 901;
      case 901:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_optimize_sampling_multipliers(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool optimize_minimize_cost = 902 [default = true];
      case 902:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_optimize_minimize_cost(&has_bits);
          optimize_minimize_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FFPilotOptions::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:lm.input.ffpilot.FFPilotOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double error_goal = 1 [default = 0.05];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_error_goal(), target);
  }

  // optional double error_goal_confidence = 2 [default = 0.95];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_error_goal_confidence(), target);
  }

  // optional int32 order_parameter_index = 3 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_order_parameter_index(), target);
  }

  // optional int32 tiling_index = 4 [default = 0];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_tiling_index(), target);
  }

  // optional bool trajectory_output = 5 [default = false];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_trajectory_output(), target);
  }

  // optional uint64 max_trajectories_per_work_unit = 6 [default = 10000];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_max_trajectories_per_work_unit(), target);
  }

  // optional .lm.input.ffpilot.FFPilotOptions.FallbackMethod fallback_method = 7 [default = FALLBACK_TILING_EDGE];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_fallback_method(), target);
  }

  // required .robertslab.pbuf.NDArray phase_zero_basins = 100;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        100, _Internal::phase_zero_basins(this), target, stream);
  }

  // optional double phase_zero_transition_barrier = 101;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(101, this->_internal_phase_zero_transition_barrier(), target);
  }

  // optional int32 phase_zero_equilibration_crossings = 102 [default = 10];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(102, this->_internal_phase_zero_equilibration_crossings(), target);
  }

  // optional int32 pilot_stage_crossings = 300 [default = 1000];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(300, this->_internal_pilot_stage_crossings(), target);
  }

  // optional bool pilot_skip = 301 [default = false];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(301, this->_internal_pilot_skip(), target);
  }

  // optional bool prod_skip = 302 [default = false];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(302, this->_internal_prod_skip(), target);
  }

  // optional .robertslab.pbuf.NDArray prod_trajectory_counts = 401;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        401, _Internal::prod_trajectory_counts(this), target, stream);
  }

  // optional uint64 optimize_minimum_trajectories = 900 [default = 1000];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(900, this->_internal_optimize_minimum_trajectories(), target);
  }

  // optional .robertslab.pbuf.NDArray optimize_sampling_multipliers = 901;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        901, _Internal::optimize_sampling_multipliers(this), target, stream);
  }

  // optional bool optimize_minimize_cost = 902 [default = true];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(902, this->_internal_optimize_minimize_cost(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lm.input.ffpilot.FFPilotOptions)
  return target;
}

size_t FFPilotOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lm.input.ffpilot.FFPilotOptions)
  size_t total_size = 0;

  // required .robertslab.pbuf.NDArray phase_zero_basins = 100;
  if (_internal_has_phase_zero_basins()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *phase_zero_basins_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional .robertslab.pbuf.NDArray prod_trajectory_counts = 401;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *prod_trajectory_counts_);
    }

    // optional .robertslab.pbuf.NDArray optimize_sampling_multipliers = 901;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *optimize_sampling_multipliers_);
    }

    // optional int32 order_parameter_index = 3 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_order_parameter_index());
    }

    // optional int32 tiling_index = 4 [default = 0];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_tiling_index());
    }

    // optional double phase_zero_transition_barrier = 101;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + 8;
    }

    // optional .lm.input.ffpilot.FFPilotOptions.FallbackMethod fallback_method = 7 [default = FALLBACK_TILING_EDGE];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_fallback_method());
    }

    // optional bool trajectory_output = 5 [default = false];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool pilot_skip = 301 [default = false];
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 + 1;
    }

    // optional bool prod_skip = 302 [default = false];
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 + 1;
    }

    // optional bool optimize_minimize_cost = 902 [default = true];
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + 1;
    }

    // optional double error_goal = 1 [default = 0.05];
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 8;
    }

    // optional double error_goal_confidence = 2 [default = 0.95];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 8;
    }

    // optional uint64 max_trajectories_per_work_unit = 6 [default = 10000];
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_max_trajectories_per_work_unit());
    }

    // optional int32 phase_zero_equilibration_crossings = 102 [default = 10];
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_phase_zero_equilibration_crossings());
    }

    // optional int32 pilot_stage_crossings = 300 [default = 1000];
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_pilot_stage_crossings());
    }

  }
  // optional uint64 optimize_minimum_trajectories = 900 [default = 1000];
  if (cached_has_bits & 0x00010000u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_optimize_minimum_trajectories());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FFPilotOptions::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:lm.input.ffpilot.FFPilotOptions)
  GOOGLE_DCHECK_NE(&from, this);
  const FFPilotOptions* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FFPilotOptions>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:lm.input.ffpilot.FFPilotOptions)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:lm.input.ffpilot.FFPilotOptions)
    MergeFrom(*source);
  }
}

void FFPilotOptions::MergeFrom(const FFPilotOptions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:lm.input.ffpilot.FFPilotOptions)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_phase_zero_basins()->::robertslab::pbuf::NDArray::MergeFrom(from._internal_phase_zero_basins());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_prod_trajectory_counts()->::robertslab::pbuf::NDArray::MergeFrom(from._internal_prod_trajectory_counts());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_optimize_sampling_multipliers()->::robertslab::pbuf::NDArray::MergeFrom(from._internal_optimize_sampling_multipliers());
    }
    if (cached_has_bits & 0x00000008u) {
      order_parameter_index_ = from.order_parameter_index_;
    }
    if (cached_has_bits & 0x00000010u) {
      tiling_index_ = from.tiling_index_;
    }
    if (cached_has_bits & 0x00000020u) {
      phase_zero_transition_barrier_ = from.phase_zero_transition_barrier_;
    }
    if (cached_has_bits & 0x00000040u) {
      fallback_method_ = from.fallback_method_;
    }
    if (cached_has_bits & 0x00000080u) {
      trajectory_output_ = from.trajectory_output_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      pilot_skip_ = from.pilot_skip_;
    }
    if (cached_has_bits & 0x00000200u) {
      prod_skip_ = from.prod_skip_;
    }
    if (cached_has_bits & 0x00000400u) {
      optimize_minimize_cost_ = from.optimize_minimize_cost_;
    }
    if (cached_has_bits & 0x00000800u) {
      error_goal_ = from.error_goal_;
    }
    if (cached_has_bits & 0x00001000u) {
      error_goal_confidence_ = from.error_goal_confidence_;
    }
    if (cached_has_bits & 0x00002000u) {
      max_trajectories_per_work_unit_ = from.max_trajectories_per_work_unit_;
    }
    if (cached_has_bits & 0x00004000u) {
      phase_zero_equilibration_crossings_ = from.phase_zero_equilibration_crossings_;
    }
    if (cached_has_bits & 0x00008000u) {
      pilot_stage_crossings_ = from.pilot_stage_crossings_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00010000u) {
    _internal_set_optimize_minimum_trajectories(from._internal_optimize_minimum_trajectories());
  }
}

void FFPilotOptions::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:lm.input.ffpilot.FFPilotOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FFPilotOptions::CopyFrom(const FFPilotOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lm.input.ffpilot.FFPilotOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FFPilotOptions::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_phase_zero_basins()) {
    if (!phase_zero_basins_->IsInitialized()) return false;
  }
  if (_internal_has_prod_trajectory_counts()) {
    if (!prod_trajectory_counts_->IsInitialized()) return false;
  }
  if (_internal_has_optimize_sampling_multipliers()) {
    if (!optimize_sampling_multipliers_->IsInitialized()) return false;
  }
  return true;
}

void FFPilotOptions::InternalSwap(FFPilotOptions* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FFPilotOptions, prod_skip_)
      + sizeof(FFPilotOptions::prod_skip_)
      - PROTOBUF_FIELD_OFFSET(FFPilotOptions, phase_zero_basins_)>(
          reinterpret_cast<char*>(&phase_zero_basins_),
          reinterpret_cast<char*>(&other->phase_zero_basins_));
  swap(optimize_minimize_cost_, other->optimize_minimize_cost_);
  swap(error_goal_, other->error_goal_);
  swap(error_goal_confidence_, other->error_goal_confidence_);
  swap(max_trajectories_per_work_unit_, other->max_trajectories_per_work_unit_);
  swap(phase_zero_equilibration_crossings_, other->phase_zero_equilibration_crossings_);
  swap(pilot_stage_crossings_, other->pilot_stage_crossings_);
  swap(optimize_minimum_trajectories_, other->optimize_minimum_trajectories_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FFPilotOptions::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace ffpilot
}  // namespace input
}  // namespace lm
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::lm::input::ffpilot::FFPilotOptions* Arena::CreateMaybeMessage< ::lm::input::ffpilot::FFPilotOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lm::input::ffpilot::FFPilotOptions >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
