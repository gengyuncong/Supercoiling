// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: lm/input/SimulationOptions.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_lm_2finput_2fSimulationOptions_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_lm_2finput_2fSimulationOptions_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_lm_2finput_2fSimulationOptions_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_lm_2finput_2fSimulationOptions_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_lm_2finput_2fSimulationOptions_2eproto;
namespace lm {
namespace input {
class BarrierLimit;
class BarrierLimitDefaultTypeInternal;
extern BarrierLimitDefaultTypeInternal _BarrierLimit_default_instance_;
class OrderParameterLimit;
class OrderParameterLimitDefaultTypeInternal;
extern OrderParameterLimitDefaultTypeInternal _OrderParameterLimit_default_instance_;
class SimulationOptions;
class SimulationOptionsDefaultTypeInternal;
extern SimulationOptionsDefaultTypeInternal _SimulationOptions_default_instance_;
class SpeciesLimit;
class SpeciesLimitDefaultTypeInternal;
extern SpeciesLimitDefaultTypeInternal _SpeciesLimit_default_instance_;
}  // namespace input
}  // namespace lm
PROTOBUF_NAMESPACE_OPEN
template<> ::lm::input::BarrierLimit* Arena::CreateMaybeMessage<::lm::input::BarrierLimit>(Arena*);
template<> ::lm::input::OrderParameterLimit* Arena::CreateMaybeMessage<::lm::input::OrderParameterLimit>(Arena*);
template<> ::lm::input::SimulationOptions* Arena::CreateMaybeMessage<::lm::input::SimulationOptions>(Arena*);
template<> ::lm::input::SpeciesLimit* Arena::CreateMaybeMessage<::lm::input::SpeciesLimit>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace lm {
namespace input {

// ===================================================================

class SimulationOptions PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lm.input.SimulationOptions) */ {
 public:
  inline SimulationOptions() : SimulationOptions(nullptr) {}
  virtual ~SimulationOptions();

  SimulationOptions(const SimulationOptions& from);
  SimulationOptions(SimulationOptions&& from) noexcept
    : SimulationOptions() {
    *this = ::std::move(from);
  }

  inline SimulationOptions& operator=(const SimulationOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimulationOptions& operator=(SimulationOptions&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimulationOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimulationOptions* internal_default_instance() {
    return reinterpret_cast<const SimulationOptions*>(
               &_SimulationOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SimulationOptions& a, SimulationOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(SimulationOptions* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimulationOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimulationOptions* New() const final {
    return CreateMaybeMessage<SimulationOptions>(nullptr);
  }

  SimulationOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimulationOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimulationOptions& from);
  void MergeFrom(const SimulationOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimulationOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lm.input.SimulationOptions";
  }
  protected:
  explicit SimulationOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_lm_2finput_2fSimulationOptions_2eproto);
    return ::descriptor_table_lm_2finput_2fSimulationOptions_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeciesUpperLimitFieldNumber = 2,
    kSpeciesLowerLimitFieldNumber = 3,
    kTrackingBarrierCrossingLimitFieldNumber = 6,
    kSpeciesReflectingBarrierFieldNumber = 10,
    kOrderParameterReflectingBarrierFieldNumber = 11,
    kSpeciesTrackingBarrierFieldNumber = 12,
    kOrderParameterTrackingBarrierFieldNumber = 13,
    kTimeLimitFieldNumber = 1,
    kPartsPerWorkUnitFieldNumber = 100,
    kStepsPerWorkUnitPartFieldNumber = 101,
  };
  // repeated .lm.input.SpeciesLimit species_upper_limit = 2;
  int species_upper_limit_size() const;
  private:
  int _internal_species_upper_limit_size() const;
  public:
  void clear_species_upper_limit();
  ::lm::input::SpeciesLimit* mutable_species_upper_limit(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::SpeciesLimit >*
      mutable_species_upper_limit();
  private:
  const ::lm::input::SpeciesLimit& _internal_species_upper_limit(int index) const;
  ::lm::input::SpeciesLimit* _internal_add_species_upper_limit();
  public:
  const ::lm::input::SpeciesLimit& species_upper_limit(int index) const;
  ::lm::input::SpeciesLimit* add_species_upper_limit();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::SpeciesLimit >&
      species_upper_limit() const;

  // repeated .lm.input.SpeciesLimit species_lower_limit = 3;
  int species_lower_limit_size() const;
  private:
  int _internal_species_lower_limit_size() const;
  public:
  void clear_species_lower_limit();
  ::lm::input::SpeciesLimit* mutable_species_lower_limit(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::SpeciesLimit >*
      mutable_species_lower_limit();
  private:
  const ::lm::input::SpeciesLimit& _internal_species_lower_limit(int index) const;
  ::lm::input::SpeciesLimit* _internal_add_species_lower_limit();
  public:
  const ::lm::input::SpeciesLimit& species_lower_limit(int index) const;
  ::lm::input::SpeciesLimit* add_species_lower_limit();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::SpeciesLimit >&
      species_lower_limit() const;

  // repeated .lm.input.BarrierLimit tracking_barrier_crossing_limit = 6;
  int tracking_barrier_crossing_limit_size() const;
  private:
  int _internal_tracking_barrier_crossing_limit_size() const;
  public:
  void clear_tracking_barrier_crossing_limit();
  ::lm::input::BarrierLimit* mutable_tracking_barrier_crossing_limit(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::BarrierLimit >*
      mutable_tracking_barrier_crossing_limit();
  private:
  const ::lm::input::BarrierLimit& _internal_tracking_barrier_crossing_limit(int index) const;
  ::lm::input::BarrierLimit* _internal_add_tracking_barrier_crossing_limit();
  public:
  const ::lm::input::BarrierLimit& tracking_barrier_crossing_limit(int index) const;
  ::lm::input::BarrierLimit* add_tracking_barrier_crossing_limit();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::BarrierLimit >&
      tracking_barrier_crossing_limit() const;

  // repeated .lm.input.SpeciesLimit species_reflecting_barrier = 10;
  int species_reflecting_barrier_size() const;
  private:
  int _internal_species_reflecting_barrier_size() const;
  public:
  void clear_species_reflecting_barrier();
  ::lm::input::SpeciesLimit* mutable_species_reflecting_barrier(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::SpeciesLimit >*
      mutable_species_reflecting_barrier();
  private:
  const ::lm::input::SpeciesLimit& _internal_species_reflecting_barrier(int index) const;
  ::lm::input::SpeciesLimit* _internal_add_species_reflecting_barrier();
  public:
  const ::lm::input::SpeciesLimit& species_reflecting_barrier(int index) const;
  ::lm::input::SpeciesLimit* add_species_reflecting_barrier();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::SpeciesLimit >&
      species_reflecting_barrier() const;

  // repeated .lm.input.OrderParameterLimit order_parameter_reflecting_barrier = 11;
  int order_parameter_reflecting_barrier_size() const;
  private:
  int _internal_order_parameter_reflecting_barrier_size() const;
  public:
  void clear_order_parameter_reflecting_barrier();
  ::lm::input::OrderParameterLimit* mutable_order_parameter_reflecting_barrier(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::OrderParameterLimit >*
      mutable_order_parameter_reflecting_barrier();
  private:
  const ::lm::input::OrderParameterLimit& _internal_order_parameter_reflecting_barrier(int index) const;
  ::lm::input::OrderParameterLimit* _internal_add_order_parameter_reflecting_barrier();
  public:
  const ::lm::input::OrderParameterLimit& order_parameter_reflecting_barrier(int index) const;
  ::lm::input::OrderParameterLimit* add_order_parameter_reflecting_barrier();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::OrderParameterLimit >&
      order_parameter_reflecting_barrier() const;

  // repeated .lm.input.SpeciesLimit species_tracking_barrier = 12;
  int species_tracking_barrier_size() const;
  private:
  int _internal_species_tracking_barrier_size() const;
  public:
  void clear_species_tracking_barrier();
  ::lm::input::SpeciesLimit* mutable_species_tracking_barrier(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::SpeciesLimit >*
      mutable_species_tracking_barrier();
  private:
  const ::lm::input::SpeciesLimit& _internal_species_tracking_barrier(int index) const;
  ::lm::input::SpeciesLimit* _internal_add_species_tracking_barrier();
  public:
  const ::lm::input::SpeciesLimit& species_tracking_barrier(int index) const;
  ::lm::input::SpeciesLimit* add_species_tracking_barrier();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::SpeciesLimit >&
      species_tracking_barrier() const;

  // repeated .lm.input.OrderParameterLimit order_parameter_tracking_barrier = 13;
  int order_parameter_tracking_barrier_size() const;
  private:
  int _internal_order_parameter_tracking_barrier_size() const;
  public:
  void clear_order_parameter_tracking_barrier();
  ::lm::input::OrderParameterLimit* mutable_order_parameter_tracking_barrier(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::OrderParameterLimit >*
      mutable_order_parameter_tracking_barrier();
  private:
  const ::lm::input::OrderParameterLimit& _internal_order_parameter_tracking_barrier(int index) const;
  ::lm::input::OrderParameterLimit* _internal_add_order_parameter_tracking_barrier();
  public:
  const ::lm::input::OrderParameterLimit& order_parameter_tracking_barrier(int index) const;
  ::lm::input::OrderParameterLimit* add_order_parameter_tracking_barrier();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::OrderParameterLimit >&
      order_parameter_tracking_barrier() const;

  // optional double time_limit = 1;
  bool has_time_limit() const;
  private:
  bool _internal_has_time_limit() const;
  public:
  void clear_time_limit();
  double time_limit() const;
  void set_time_limit(double value);
  private:
  double _internal_time_limit() const;
  void _internal_set_time_limit(double value);
  public:

  // optional uint64 parts_per_work_unit = 100 [default = 1];
  bool has_parts_per_work_unit() const;
  private:
  bool _internal_has_parts_per_work_unit() const;
  public:
  void clear_parts_per_work_unit();
  ::PROTOBUF_NAMESPACE_ID::uint64 parts_per_work_unit() const;
  void set_parts_per_work_unit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_parts_per_work_unit() const;
  void _internal_set_parts_per_work_unit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 steps_per_work_unit_part = 101 [default = 100000000];
  bool has_steps_per_work_unit_part() const;
  private:
  bool _internal_has_steps_per_work_unit_part() const;
  public:
  void clear_steps_per_work_unit_part();
  ::PROTOBUF_NAMESPACE_ID::uint64 steps_per_work_unit_part() const;
  void set_steps_per_work_unit_part(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_steps_per_work_unit_part() const;
  void _internal_set_steps_per_work_unit_part(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:lm.input.SimulationOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::SpeciesLimit > species_upper_limit_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::SpeciesLimit > species_lower_limit_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::BarrierLimit > tracking_barrier_crossing_limit_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::SpeciesLimit > species_reflecting_barrier_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::OrderParameterLimit > order_parameter_reflecting_barrier_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::SpeciesLimit > species_tracking_barrier_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::OrderParameterLimit > order_parameter_tracking_barrier_;
  double time_limit_;
  ::PROTOBUF_NAMESPACE_ID::uint64 parts_per_work_unit_;
  ::PROTOBUF_NAMESPACE_ID::uint64 steps_per_work_unit_part_;
  friend struct ::TableStruct_lm_2finput_2fSimulationOptions_2eproto;
};
// -------------------------------------------------------------------

class SpeciesLimit PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lm.input.SpeciesLimit) */ {
 public:
  inline SpeciesLimit() : SpeciesLimit(nullptr) {}
  virtual ~SpeciesLimit();

  SpeciesLimit(const SpeciesLimit& from);
  SpeciesLimit(SpeciesLimit&& from) noexcept
    : SpeciesLimit() {
    *this = ::std::move(from);
  }

  inline SpeciesLimit& operator=(const SpeciesLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeciesLimit& operator=(SpeciesLimit&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpeciesLimit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpeciesLimit* internal_default_instance() {
    return reinterpret_cast<const SpeciesLimit*>(
               &_SpeciesLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SpeciesLimit& a, SpeciesLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeciesLimit* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeciesLimit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpeciesLimit* New() const final {
    return CreateMaybeMessage<SpeciesLimit>(nullptr);
  }

  SpeciesLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpeciesLimit>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpeciesLimit& from);
  void MergeFrom(const SpeciesLimit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeciesLimit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lm.input.SpeciesLimit";
  }
  protected:
  explicit SpeciesLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_lm_2finput_2fSimulationOptions_2eproto);
    return ::descriptor_table_lm_2finput_2fSimulationOptions_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeciesIndexFieldNumber = 1,
    kLimitValueFieldNumber = 2,
  };
  // required uint32 species_index = 1;
  bool has_species_index() const;
  private:
  bool _internal_has_species_index() const;
  public:
  void clear_species_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 species_index() const;
  void set_species_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_species_index() const;
  void _internal_set_species_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required int32 limit_value = 2;
  bool has_limit_value() const;
  private:
  bool _internal_has_limit_value() const;
  public:
  void clear_limit_value();
  ::PROTOBUF_NAMESPACE_ID::int32 limit_value() const;
  void set_limit_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_limit_value() const;
  void _internal_set_limit_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:lm.input.SpeciesLimit)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 species_index_;
  ::PROTOBUF_NAMESPACE_ID::int32 limit_value_;
  friend struct ::TableStruct_lm_2finput_2fSimulationOptions_2eproto;
};
// -------------------------------------------------------------------

class OrderParameterLimit PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lm.input.OrderParameterLimit) */ {
 public:
  inline OrderParameterLimit() : OrderParameterLimit(nullptr) {}
  virtual ~OrderParameterLimit();

  OrderParameterLimit(const OrderParameterLimit& from);
  OrderParameterLimit(OrderParameterLimit&& from) noexcept
    : OrderParameterLimit() {
    *this = ::std::move(from);
  }

  inline OrderParameterLimit& operator=(const OrderParameterLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderParameterLimit& operator=(OrderParameterLimit&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OrderParameterLimit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrderParameterLimit* internal_default_instance() {
    return reinterpret_cast<const OrderParameterLimit*>(
               &_OrderParameterLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OrderParameterLimit& a, OrderParameterLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderParameterLimit* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderParameterLimit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OrderParameterLimit* New() const final {
    return CreateMaybeMessage<OrderParameterLimit>(nullptr);
  }

  OrderParameterLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OrderParameterLimit>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OrderParameterLimit& from);
  void MergeFrom(const OrderParameterLimit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderParameterLimit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lm.input.OrderParameterLimit";
  }
  protected:
  explicit OrderParameterLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_lm_2finput_2fSimulationOptions_2eproto);
    return ::descriptor_table_lm_2finput_2fSimulationOptions_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLimitValueFieldNumber = 2,
    kOrderParameterIndexFieldNumber = 1,
  };
  // required double limit_value = 2;
  bool has_limit_value() const;
  private:
  bool _internal_has_limit_value() const;
  public:
  void clear_limit_value();
  double limit_value() const;
  void set_limit_value(double value);
  private:
  double _internal_limit_value() const;
  void _internal_set_limit_value(double value);
  public:

  // required uint32 order_parameter_index = 1;
  bool has_order_parameter_index() const;
  private:
  bool _internal_has_order_parameter_index() const;
  public:
  void clear_order_parameter_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 order_parameter_index() const;
  void set_order_parameter_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_order_parameter_index() const;
  void _internal_set_order_parameter_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:lm.input.OrderParameterLimit)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double limit_value_;
  ::PROTOBUF_NAMESPACE_ID::uint32 order_parameter_index_;
  friend struct ::TableStruct_lm_2finput_2fSimulationOptions_2eproto;
};
// -------------------------------------------------------------------

class BarrierLimit PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lm.input.BarrierLimit) */ {
 public:
  inline BarrierLimit() : BarrierLimit(nullptr) {}
  virtual ~BarrierLimit();

  BarrierLimit(const BarrierLimit& from);
  BarrierLimit(BarrierLimit&& from) noexcept
    : BarrierLimit() {
    *this = ::std::move(from);
  }

  inline BarrierLimit& operator=(const BarrierLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline BarrierLimit& operator=(BarrierLimit&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BarrierLimit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BarrierLimit* internal_default_instance() {
    return reinterpret_cast<const BarrierLimit*>(
               &_BarrierLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BarrierLimit& a, BarrierLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(BarrierLimit* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BarrierLimit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BarrierLimit* New() const final {
    return CreateMaybeMessage<BarrierLimit>(nullptr);
  }

  BarrierLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BarrierLimit>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BarrierLimit& from);
  void MergeFrom(const BarrierLimit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BarrierLimit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lm.input.BarrierLimit";
  }
  protected:
  explicit BarrierLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_lm_2finput_2fSimulationOptions_2eproto);
    return ::descriptor_table_lm_2finput_2fSimulationOptions_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBarrierIndexFieldNumber = 1,
    kLimitValueFieldNumber = 2,
  };
  // required uint32 barrier_index = 1;
  bool has_barrier_index() const;
  private:
  bool _internal_has_barrier_index() const;
  public:
  void clear_barrier_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 barrier_index() const;
  void set_barrier_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_barrier_index() const;
  void _internal_set_barrier_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 limit_value = 2;
  bool has_limit_value() const;
  private:
  bool _internal_has_limit_value() const;
  public:
  void clear_limit_value();
  ::PROTOBUF_NAMESPACE_ID::uint32 limit_value() const;
  void set_limit_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_limit_value() const;
  void _internal_set_limit_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:lm.input.BarrierLimit)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 barrier_index_;
  ::PROTOBUF_NAMESPACE_ID::uint32 limit_value_;
  friend struct ::TableStruct_lm_2finput_2fSimulationOptions_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SimulationOptions

// optional double time_limit = 1;
inline bool SimulationOptions::_internal_has_time_limit() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SimulationOptions::has_time_limit() const {
  return _internal_has_time_limit();
}
inline void SimulationOptions::clear_time_limit() {
  time_limit_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double SimulationOptions::_internal_time_limit() const {
  return time_limit_;
}
inline double SimulationOptions::time_limit() const {
  // @@protoc_insertion_point(field_get:lm.input.SimulationOptions.time_limit)
  return _internal_time_limit();
}
inline void SimulationOptions::_internal_set_time_limit(double value) {
  _has_bits_[0] |= 0x00000001u;
  time_limit_ = value;
}
inline void SimulationOptions::set_time_limit(double value) {
  _internal_set_time_limit(value);
  // @@protoc_insertion_point(field_set:lm.input.SimulationOptions.time_limit)
}

// repeated .lm.input.SpeciesLimit species_upper_limit = 2;
inline int SimulationOptions::_internal_species_upper_limit_size() const {
  return species_upper_limit_.size();
}
inline int SimulationOptions::species_upper_limit_size() const {
  return _internal_species_upper_limit_size();
}
inline void SimulationOptions::clear_species_upper_limit() {
  species_upper_limit_.Clear();
}
inline ::lm::input::SpeciesLimit* SimulationOptions::mutable_species_upper_limit(int index) {
  // @@protoc_insertion_point(field_mutable:lm.input.SimulationOptions.species_upper_limit)
  return species_upper_limit_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::SpeciesLimit >*
SimulationOptions::mutable_species_upper_limit() {
  // @@protoc_insertion_point(field_mutable_list:lm.input.SimulationOptions.species_upper_limit)
  return &species_upper_limit_;
}
inline const ::lm::input::SpeciesLimit& SimulationOptions::_internal_species_upper_limit(int index) const {
  return species_upper_limit_.Get(index);
}
inline const ::lm::input::SpeciesLimit& SimulationOptions::species_upper_limit(int index) const {
  // @@protoc_insertion_point(field_get:lm.input.SimulationOptions.species_upper_limit)
  return _internal_species_upper_limit(index);
}
inline ::lm::input::SpeciesLimit* SimulationOptions::_internal_add_species_upper_limit() {
  return species_upper_limit_.Add();
}
inline ::lm::input::SpeciesLimit* SimulationOptions::add_species_upper_limit() {
  // @@protoc_insertion_point(field_add:lm.input.SimulationOptions.species_upper_limit)
  return _internal_add_species_upper_limit();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::SpeciesLimit >&
SimulationOptions::species_upper_limit() const {
  // @@protoc_insertion_point(field_list:lm.input.SimulationOptions.species_upper_limit)
  return species_upper_limit_;
}

// repeated .lm.input.SpeciesLimit species_lower_limit = 3;
inline int SimulationOptions::_internal_species_lower_limit_size() const {
  return species_lower_limit_.size();
}
inline int SimulationOptions::species_lower_limit_size() const {
  return _internal_species_lower_limit_size();
}
inline void SimulationOptions::clear_species_lower_limit() {
  species_lower_limit_.Clear();
}
inline ::lm::input::SpeciesLimit* SimulationOptions::mutable_species_lower_limit(int index) {
  // @@protoc_insertion_point(field_mutable:lm.input.SimulationOptions.species_lower_limit)
  return species_lower_limit_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::SpeciesLimit >*
SimulationOptions::mutable_species_lower_limit() {
  // @@protoc_insertion_point(field_mutable_list:lm.input.SimulationOptions.species_lower_limit)
  return &species_lower_limit_;
}
inline const ::lm::input::SpeciesLimit& SimulationOptions::_internal_species_lower_limit(int index) const {
  return species_lower_limit_.Get(index);
}
inline const ::lm::input::SpeciesLimit& SimulationOptions::species_lower_limit(int index) const {
  // @@protoc_insertion_point(field_get:lm.input.SimulationOptions.species_lower_limit)
  return _internal_species_lower_limit(index);
}
inline ::lm::input::SpeciesLimit* SimulationOptions::_internal_add_species_lower_limit() {
  return species_lower_limit_.Add();
}
inline ::lm::input::SpeciesLimit* SimulationOptions::add_species_lower_limit() {
  // @@protoc_insertion_point(field_add:lm.input.SimulationOptions.species_lower_limit)
  return _internal_add_species_lower_limit();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::SpeciesLimit >&
SimulationOptions::species_lower_limit() const {
  // @@protoc_insertion_point(field_list:lm.input.SimulationOptions.species_lower_limit)
  return species_lower_limit_;
}

// repeated .lm.input.BarrierLimit tracking_barrier_crossing_limit = 6;
inline int SimulationOptions::_internal_tracking_barrier_crossing_limit_size() const {
  return tracking_barrier_crossing_limit_.size();
}
inline int SimulationOptions::tracking_barrier_crossing_limit_size() const {
  return _internal_tracking_barrier_crossing_limit_size();
}
inline void SimulationOptions::clear_tracking_barrier_crossing_limit() {
  tracking_barrier_crossing_limit_.Clear();
}
inline ::lm::input::BarrierLimit* SimulationOptions::mutable_tracking_barrier_crossing_limit(int index) {
  // @@protoc_insertion_point(field_mutable:lm.input.SimulationOptions.tracking_barrier_crossing_limit)
  return tracking_barrier_crossing_limit_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::BarrierLimit >*
SimulationOptions::mutable_tracking_barrier_crossing_limit() {
  // @@protoc_insertion_point(field_mutable_list:lm.input.SimulationOptions.tracking_barrier_crossing_limit)
  return &tracking_barrier_crossing_limit_;
}
inline const ::lm::input::BarrierLimit& SimulationOptions::_internal_tracking_barrier_crossing_limit(int index) const {
  return tracking_barrier_crossing_limit_.Get(index);
}
inline const ::lm::input::BarrierLimit& SimulationOptions::tracking_barrier_crossing_limit(int index) const {
  // @@protoc_insertion_point(field_get:lm.input.SimulationOptions.tracking_barrier_crossing_limit)
  return _internal_tracking_barrier_crossing_limit(index);
}
inline ::lm::input::BarrierLimit* SimulationOptions::_internal_add_tracking_barrier_crossing_limit() {
  return tracking_barrier_crossing_limit_.Add();
}
inline ::lm::input::BarrierLimit* SimulationOptions::add_tracking_barrier_crossing_limit() {
  // @@protoc_insertion_point(field_add:lm.input.SimulationOptions.tracking_barrier_crossing_limit)
  return _internal_add_tracking_barrier_crossing_limit();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::BarrierLimit >&
SimulationOptions::tracking_barrier_crossing_limit() const {
  // @@protoc_insertion_point(field_list:lm.input.SimulationOptions.tracking_barrier_crossing_limit)
  return tracking_barrier_crossing_limit_;
}

// repeated .lm.input.SpeciesLimit species_reflecting_barrier = 10;
inline int SimulationOptions::_internal_species_reflecting_barrier_size() const {
  return species_reflecting_barrier_.size();
}
inline int SimulationOptions::species_reflecting_barrier_size() const {
  return _internal_species_reflecting_barrier_size();
}
inline void SimulationOptions::clear_species_reflecting_barrier() {
  species_reflecting_barrier_.Clear();
}
inline ::lm::input::SpeciesLimit* SimulationOptions::mutable_species_reflecting_barrier(int index) {
  // @@protoc_insertion_point(field_mutable:lm.input.SimulationOptions.species_reflecting_barrier)
  return species_reflecting_barrier_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::SpeciesLimit >*
SimulationOptions::mutable_species_reflecting_barrier() {
  // @@protoc_insertion_point(field_mutable_list:lm.input.SimulationOptions.species_reflecting_barrier)
  return &species_reflecting_barrier_;
}
inline const ::lm::input::SpeciesLimit& SimulationOptions::_internal_species_reflecting_barrier(int index) const {
  return species_reflecting_barrier_.Get(index);
}
inline const ::lm::input::SpeciesLimit& SimulationOptions::species_reflecting_barrier(int index) const {
  // @@protoc_insertion_point(field_get:lm.input.SimulationOptions.species_reflecting_barrier)
  return _internal_species_reflecting_barrier(index);
}
inline ::lm::input::SpeciesLimit* SimulationOptions::_internal_add_species_reflecting_barrier() {
  return species_reflecting_barrier_.Add();
}
inline ::lm::input::SpeciesLimit* SimulationOptions::add_species_reflecting_barrier() {
  // @@protoc_insertion_point(field_add:lm.input.SimulationOptions.species_reflecting_barrier)
  return _internal_add_species_reflecting_barrier();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::SpeciesLimit >&
SimulationOptions::species_reflecting_barrier() const {
  // @@protoc_insertion_point(field_list:lm.input.SimulationOptions.species_reflecting_barrier)
  return species_reflecting_barrier_;
}

// repeated .lm.input.OrderParameterLimit order_parameter_reflecting_barrier = 11;
inline int SimulationOptions::_internal_order_parameter_reflecting_barrier_size() const {
  return order_parameter_reflecting_barrier_.size();
}
inline int SimulationOptions::order_parameter_reflecting_barrier_size() const {
  return _internal_order_parameter_reflecting_barrier_size();
}
inline void SimulationOptions::clear_order_parameter_reflecting_barrier() {
  order_parameter_reflecting_barrier_.Clear();
}
inline ::lm::input::OrderParameterLimit* SimulationOptions::mutable_order_parameter_reflecting_barrier(int index) {
  // @@protoc_insertion_point(field_mutable:lm.input.SimulationOptions.order_parameter_reflecting_barrier)
  return order_parameter_reflecting_barrier_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::OrderParameterLimit >*
SimulationOptions::mutable_order_parameter_reflecting_barrier() {
  // @@protoc_insertion_point(field_mutable_list:lm.input.SimulationOptions.order_parameter_reflecting_barrier)
  return &order_parameter_reflecting_barrier_;
}
inline const ::lm::input::OrderParameterLimit& SimulationOptions::_internal_order_parameter_reflecting_barrier(int index) const {
  return order_parameter_reflecting_barrier_.Get(index);
}
inline const ::lm::input::OrderParameterLimit& SimulationOptions::order_parameter_reflecting_barrier(int index) const {
  // @@protoc_insertion_point(field_get:lm.input.SimulationOptions.order_parameter_reflecting_barrier)
  return _internal_order_parameter_reflecting_barrier(index);
}
inline ::lm::input::OrderParameterLimit* SimulationOptions::_internal_add_order_parameter_reflecting_barrier() {
  return order_parameter_reflecting_barrier_.Add();
}
inline ::lm::input::OrderParameterLimit* SimulationOptions::add_order_parameter_reflecting_barrier() {
  // @@protoc_insertion_point(field_add:lm.input.SimulationOptions.order_parameter_reflecting_barrier)
  return _internal_add_order_parameter_reflecting_barrier();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::OrderParameterLimit >&
SimulationOptions::order_parameter_reflecting_barrier() const {
  // @@protoc_insertion_point(field_list:lm.input.SimulationOptions.order_parameter_reflecting_barrier)
  return order_parameter_reflecting_barrier_;
}

// repeated .lm.input.SpeciesLimit species_tracking_barrier = 12;
inline int SimulationOptions::_internal_species_tracking_barrier_size() const {
  return species_tracking_barrier_.size();
}
inline int SimulationOptions::species_tracking_barrier_size() const {
  return _internal_species_tracking_barrier_size();
}
inline void SimulationOptions::clear_species_tracking_barrier() {
  species_tracking_barrier_.Clear();
}
inline ::lm::input::SpeciesLimit* SimulationOptions::mutable_species_tracking_barrier(int index) {
  // @@protoc_insertion_point(field_mutable:lm.input.SimulationOptions.species_tracking_barrier)
  return species_tracking_barrier_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::SpeciesLimit >*
SimulationOptions::mutable_species_tracking_barrier() {
  // @@protoc_insertion_point(field_mutable_list:lm.input.SimulationOptions.species_tracking_barrier)
  return &species_tracking_barrier_;
}
inline const ::lm::input::SpeciesLimit& SimulationOptions::_internal_species_tracking_barrier(int index) const {
  return species_tracking_barrier_.Get(index);
}
inline const ::lm::input::SpeciesLimit& SimulationOptions::species_tracking_barrier(int index) const {
  // @@protoc_insertion_point(field_get:lm.input.SimulationOptions.species_tracking_barrier)
  return _internal_species_tracking_barrier(index);
}
inline ::lm::input::SpeciesLimit* SimulationOptions::_internal_add_species_tracking_barrier() {
  return species_tracking_barrier_.Add();
}
inline ::lm::input::SpeciesLimit* SimulationOptions::add_species_tracking_barrier() {
  // @@protoc_insertion_point(field_add:lm.input.SimulationOptions.species_tracking_barrier)
  return _internal_add_species_tracking_barrier();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::SpeciesLimit >&
SimulationOptions::species_tracking_barrier() const {
  // @@protoc_insertion_point(field_list:lm.input.SimulationOptions.species_tracking_barrier)
  return species_tracking_barrier_;
}

// repeated .lm.input.OrderParameterLimit order_parameter_tracking_barrier = 13;
inline int SimulationOptions::_internal_order_parameter_tracking_barrier_size() const {
  return order_parameter_tracking_barrier_.size();
}
inline int SimulationOptions::order_parameter_tracking_barrier_size() const {
  return _internal_order_parameter_tracking_barrier_size();
}
inline void SimulationOptions::clear_order_parameter_tracking_barrier() {
  order_parameter_tracking_barrier_.Clear();
}
inline ::lm::input::OrderParameterLimit* SimulationOptions::mutable_order_parameter_tracking_barrier(int index) {
  // @@protoc_insertion_point(field_mutable:lm.input.SimulationOptions.order_parameter_tracking_barrier)
  return order_parameter_tracking_barrier_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::OrderParameterLimit >*
SimulationOptions::mutable_order_parameter_tracking_barrier() {
  // @@protoc_insertion_point(field_mutable_list:lm.input.SimulationOptions.order_parameter_tracking_barrier)
  return &order_parameter_tracking_barrier_;
}
inline const ::lm::input::OrderParameterLimit& SimulationOptions::_internal_order_parameter_tracking_barrier(int index) const {
  return order_parameter_tracking_barrier_.Get(index);
}
inline const ::lm::input::OrderParameterLimit& SimulationOptions::order_parameter_tracking_barrier(int index) const {
  // @@protoc_insertion_point(field_get:lm.input.SimulationOptions.order_parameter_tracking_barrier)
  return _internal_order_parameter_tracking_barrier(index);
}
inline ::lm::input::OrderParameterLimit* SimulationOptions::_internal_add_order_parameter_tracking_barrier() {
  return order_parameter_tracking_barrier_.Add();
}
inline ::lm::input::OrderParameterLimit* SimulationOptions::add_order_parameter_tracking_barrier() {
  // @@protoc_insertion_point(field_add:lm.input.SimulationOptions.order_parameter_tracking_barrier)
  return _internal_add_order_parameter_tracking_barrier();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lm::input::OrderParameterLimit >&
SimulationOptions::order_parameter_tracking_barrier() const {
  // @@protoc_insertion_point(field_list:lm.input.SimulationOptions.order_parameter_tracking_barrier)
  return order_parameter_tracking_barrier_;
}

// optional uint64 parts_per_work_unit = 100 [default = 1];
inline bool SimulationOptions::_internal_has_parts_per_work_unit() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SimulationOptions::has_parts_per_work_unit() const {
  return _internal_has_parts_per_work_unit();
}
inline void SimulationOptions::clear_parts_per_work_unit() {
  parts_per_work_unit_ = PROTOBUF_ULONGLONG(1);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SimulationOptions::_internal_parts_per_work_unit() const {
  return parts_per_work_unit_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SimulationOptions::parts_per_work_unit() const {
  // @@protoc_insertion_point(field_get:lm.input.SimulationOptions.parts_per_work_unit)
  return _internal_parts_per_work_unit();
}
inline void SimulationOptions::_internal_set_parts_per_work_unit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  parts_per_work_unit_ = value;
}
inline void SimulationOptions::set_parts_per_work_unit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_parts_per_work_unit(value);
  // @@protoc_insertion_point(field_set:lm.input.SimulationOptions.parts_per_work_unit)
}

// optional uint64 steps_per_work_unit_part = 101 [default = 100000000];
inline bool SimulationOptions::_internal_has_steps_per_work_unit_part() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SimulationOptions::has_steps_per_work_unit_part() const {
  return _internal_has_steps_per_work_unit_part();
}
inline void SimulationOptions::clear_steps_per_work_unit_part() {
  steps_per_work_unit_part_ = PROTOBUF_ULONGLONG(100000000);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SimulationOptions::_internal_steps_per_work_unit_part() const {
  return steps_per_work_unit_part_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SimulationOptions::steps_per_work_unit_part() const {
  // @@protoc_insertion_point(field_get:lm.input.SimulationOptions.steps_per_work_unit_part)
  return _internal_steps_per_work_unit_part();
}
inline void SimulationOptions::_internal_set_steps_per_work_unit_part(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  steps_per_work_unit_part_ = value;
}
inline void SimulationOptions::set_steps_per_work_unit_part(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_steps_per_work_unit_part(value);
  // @@protoc_insertion_point(field_set:lm.input.SimulationOptions.steps_per_work_unit_part)
}

// -------------------------------------------------------------------

// SpeciesLimit

// required uint32 species_index = 1;
inline bool SpeciesLimit::_internal_has_species_index() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SpeciesLimit::has_species_index() const {
  return _internal_has_species_index();
}
inline void SpeciesLimit::clear_species_index() {
  species_index_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SpeciesLimit::_internal_species_index() const {
  return species_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SpeciesLimit::species_index() const {
  // @@protoc_insertion_point(field_get:lm.input.SpeciesLimit.species_index)
  return _internal_species_index();
}
inline void SpeciesLimit::_internal_set_species_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  species_index_ = value;
}
inline void SpeciesLimit::set_species_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_species_index(value);
  // @@protoc_insertion_point(field_set:lm.input.SpeciesLimit.species_index)
}

// required int32 limit_value = 2;
inline bool SpeciesLimit::_internal_has_limit_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SpeciesLimit::has_limit_value() const {
  return _internal_has_limit_value();
}
inline void SpeciesLimit::clear_limit_value() {
  limit_value_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpeciesLimit::_internal_limit_value() const {
  return limit_value_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpeciesLimit::limit_value() const {
  // @@protoc_insertion_point(field_get:lm.input.SpeciesLimit.limit_value)
  return _internal_limit_value();
}
inline void SpeciesLimit::_internal_set_limit_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  limit_value_ = value;
}
inline void SpeciesLimit::set_limit_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_limit_value(value);
  // @@protoc_insertion_point(field_set:lm.input.SpeciesLimit.limit_value)
}

// -------------------------------------------------------------------

// OrderParameterLimit

// required uint32 order_parameter_index = 1;
inline bool OrderParameterLimit::_internal_has_order_parameter_index() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OrderParameterLimit::has_order_parameter_index() const {
  return _internal_has_order_parameter_index();
}
inline void OrderParameterLimit::clear_order_parameter_index() {
  order_parameter_index_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OrderParameterLimit::_internal_order_parameter_index() const {
  return order_parameter_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OrderParameterLimit::order_parameter_index() const {
  // @@protoc_insertion_point(field_get:lm.input.OrderParameterLimit.order_parameter_index)
  return _internal_order_parameter_index();
}
inline void OrderParameterLimit::_internal_set_order_parameter_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  order_parameter_index_ = value;
}
inline void OrderParameterLimit::set_order_parameter_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_order_parameter_index(value);
  // @@protoc_insertion_point(field_set:lm.input.OrderParameterLimit.order_parameter_index)
}

// required double limit_value = 2;
inline bool OrderParameterLimit::_internal_has_limit_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OrderParameterLimit::has_limit_value() const {
  return _internal_has_limit_value();
}
inline void OrderParameterLimit::clear_limit_value() {
  limit_value_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double OrderParameterLimit::_internal_limit_value() const {
  return limit_value_;
}
inline double OrderParameterLimit::limit_value() const {
  // @@protoc_insertion_point(field_get:lm.input.OrderParameterLimit.limit_value)
  return _internal_limit_value();
}
inline void OrderParameterLimit::_internal_set_limit_value(double value) {
  _has_bits_[0] |= 0x00000001u;
  limit_value_ = value;
}
inline void OrderParameterLimit::set_limit_value(double value) {
  _internal_set_limit_value(value);
  // @@protoc_insertion_point(field_set:lm.input.OrderParameterLimit.limit_value)
}

// -------------------------------------------------------------------

// BarrierLimit

// required uint32 barrier_index = 1;
inline bool BarrierLimit::_internal_has_barrier_index() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BarrierLimit::has_barrier_index() const {
  return _internal_has_barrier_index();
}
inline void BarrierLimit::clear_barrier_index() {
  barrier_index_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BarrierLimit::_internal_barrier_index() const {
  return barrier_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BarrierLimit::barrier_index() const {
  // @@protoc_insertion_point(field_get:lm.input.BarrierLimit.barrier_index)
  return _internal_barrier_index();
}
inline void BarrierLimit::_internal_set_barrier_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  barrier_index_ = value;
}
inline void BarrierLimit::set_barrier_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_barrier_index(value);
  // @@protoc_insertion_point(field_set:lm.input.BarrierLimit.barrier_index)
}

// required uint32 limit_value = 2;
inline bool BarrierLimit::_internal_has_limit_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BarrierLimit::has_limit_value() const {
  return _internal_has_limit_value();
}
inline void BarrierLimit::clear_limit_value() {
  limit_value_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BarrierLimit::_internal_limit_value() const {
  return limit_value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BarrierLimit::limit_value() const {
  // @@protoc_insertion_point(field_get:lm.input.BarrierLimit.limit_value)
  return _internal_limit_value();
}
inline void BarrierLimit::_internal_set_limit_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  limit_value_ = value;
}
inline void BarrierLimit::set_limit_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_limit_value(value);
  // @@protoc_insertion_point(field_set:lm.input.BarrierLimit.limit_value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace input
}  // namespace lm

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_lm_2finput_2fSimulationOptions_2eproto
